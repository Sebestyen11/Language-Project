<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Language Tree — Top→Down</title>
<style>
:root{
  --bg1:#f3f7fa;
  --bg2:#e0ebf5;
  --box:#ffffff;
  --accent:#5b9bd5;
  --accent-dark:#0078d4;
  --muted:#a0bcd0;
}
html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Arial,sans-serif;background:linear-gradient(135deg,var(--bg1),var(--bg2));-webkit-font-smoothing:antialiased;}
#tree-container{width:100vw;height:100vh;touch-action:none;cursor:grab;overflow:hidden}
svg{width:100%;height:100%;display:block;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;}
#tree-group{transition: transform 0.08s linear;}
.node rect{stroke:var(--accent);stroke-width:2;rx:8;ry:8;filter:drop-shadow(0 3px 8px rgba(0,0,0,0.12));user-select:none;}
.node:hover rect{stroke:var(--accent-dark); transform:scale(1.02);}
.node text{font-size:13px;pointer-events:none;fill:#111;font-weight:600;user-select:none;}
.link{stroke:var(--muted);stroke-width:2; fill:none}
.popup{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;border-radius:12px;padding:18px 22px;box-shadow:0 10px 30px rgba(0,0,0,0.2);max-width:420px;z-index:1002;display:none}
.popup h2{margin:0 0 8px 0;color:var(--accent-dark);font-size:18px}
.popup p{margin:0;color:#333}
.popup .close{position:absolute;right:12px;top:8px;font-size:20px;color:var(--accent-dark);cursor:pointer}
.overlay{position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.35);z-index:1001;display:none}
#searchContainer{position:fixed;top:12px;left:12px;z-index:2000;}
#searchBox{padding:6px 10px;border-radius:6px;border:1px solid #ccc;font-size:14px;width:180px;}
#searchDropdown{background:#fff;border:1px solid #ccc;border-radius:6px;margin-top:2px;max-height:200px;overflow-y:auto;display:none;}
@media (max-width:480px){ .node text{font-size:12px} }
</style>
</head>
<body>

<div id="tree-container">
  <svg id="tree-svg" xmlns="http://www.w3.org/2000/svg">
    <g id="tree-group"></g>
  </svg>
</div>

<div id="searchContainer">
  <input id="searchBox" type="text" placeholder="Search language...">
  <div id="searchDropdown"></div>
</div>

<div class="overlay" id="overlay"></div>

<div class="popup" id="popup">
  <span class="close" id="closePopup">&times;</span>
  <h2 id="popupTitle">Title</h2>
  <p id="popupInfo">Info</p>
</div>

<script>
const BOX_W = 140, BOX_H = 44, LEVEL_V_GAP = 120, LEAF_H_SPACING = 24;
const svg = document.getElementById('tree-svg');
const group = document.getElementById('tree-group');
const overlay = document.getElementById('overlay');
const popup = document.getElementById('popup');
const popupTitle = document.getElementById('popupTitle');
const popupInfo = document.getElementById('popupInfo');
const closePopup = document.getElementById('closePopup');
const searchBox = document.getElementById('searchBox');
const searchDropdown = document.getElementById('searchDropdown');

let panX=0, panY=0, scale=1;
let dragging=false, startX=0, startY=0;
let lastTouchDist=null, initialScale=1, initialPan={x:0,y:0};
let allNodes=[];

function applyTransform(){ group.setAttribute('transform', `translate(${panX},${panY}) scale(${scale})`); }
function showPopup(title, info){ popupTitle.textContent=title||'No title'; popupInfo.textContent=info||'No information'; popup.style.display='block'; overlay.style.display='block'; }
function hidePopup(){ popup.style.display='none'; overlay.style.display='none'; }
closePopup.addEventListener('click', hidePopup);
overlay.addEventListener('click', hidePopup);

// ---------- Zoom (desktop) ----------
svg.addEventListener('wheel', e=>{
  e.preventDefault();
  const rect = svg.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const zoomFactor = e.deltaY<0?1.06:0.94;
  const newScale = scale*zoomFactor;
  if(newScale<0.5||newScale>3) return;
  panX = cx - (cx-panX)*(newScale/scale);
  panY = cy - (cy-panY)*(newScale/scale);
  scale=newScale; applyTransform();
},{passive:false});

// ---------- Drag ----------
svg.addEventListener('mousedown', e=>{ dragging=true; startX=e.clientX-panX; startY=e.clientY-panY; svg.style.cursor='grabbing'; });
window.addEventListener('mousemove', e=>{ if(!dragging) return; panX=e.clientX-startX; panY=e.clientY-startY; applyTransform(); });
window.addEventListener('mouseup', ()=>{ dragging=false; svg.style.cursor='grab'; });

// ---------- Touch ----------
svg.addEventListener('touchstart', e=>{
  if(e.touches.length===1){ dragging=true; startX=e.touches[0].clientX-panX; startY=e.touches[0].clientY-panY; }
  else if(e.touches.length===2){
    lastTouchDist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
    initialScale = scale;
    initialPan = {x: panX, y: panY};
  }
});
svg.addEventListener('touchmove', e=>{
  if(e.touches.length===1 && dragging){ panX=e.touches[0].clientX-startX; panY=e.touches[0].clientY-startY; applyTransform(); }
  else if(e.touches.length===2 && lastTouchDist){
    e.preventDefault();
    const dist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
    const factor = dist / lastTouchDist;
    const newScale = Math.min(3, Math.max(0.5, initialScale * factor));
    const rect = svg.getBoundingClientRect();
    const midX = (e.touches[0].clientX+e.touches[1].clientX)/2 - rect.left;
    const midY = (e.touches[0].clientY+e.touches[1].clientY)/2 - rect.top;
    panX = midX - (midX - initialPan.x) * (newScale/initialScale);
    panY = midY - (midY - initialPan.y) * (newScale/initialScale);
    scale = newScale;
    applyTransform();
  }
});
svg.addEventListener('touchend', e=>{ if(e.touches.length<2) lastTouchDist=null; if(e.touches.length===0) dragging=false; });

// ---------- Tree Layout ----------
function computeLeafCounts(node){ if(!node.children||node.children.length===0){ node._leafCount=1; return 1;} let sum=0; node.children.forEach(c=>sum+=computeLeafCounts(c)); node._leafCount=sum; return sum;}
function assignPositions(node, depth, xOffsetRef){ const levelY=40+depth*120; if(!node.children||node.children.length===0){ const x=xOffsetRef.value+BOX_W/2; node._x=x; node._y=levelY; xOffsetRef.value+=BOX_W+24; } else{ node.children.forEach(c=>assignPositions(c,depth+1,xOffsetRef)); const first=node.children[0], last=node.children[node.children.length-1]; node._x=(first._x+last._x)/2; node._y=levelY;}}
function drawConnector(px,py,cx,cy){ const parentBottomY=py+BOX_H/2; const childTopY=cy-BOX_H/2; const midY=(parentBottomY+childTopY)/2; const d=`M ${px} ${parentBottomY} L ${px} ${midY} L ${cx} ${midY} L ${cx} ${childTopY}`; const path=document.createElementNS('http://www.w3.org/2000/svg','path'); path.setAttribute('d',d); path.setAttribute('class','link'); return path;}
function buildTree(data){
  data.forEach(root=>computeLeafCounts(root));
  const xOffsetRef={value:40}; data.forEach(root=>assignPositions(root,0,xOffsetRef));
  group.innerHTML=''; allNodes=[]; const nodes=[];
  function collect(node){ nodes.push(node); allNodes.push(node); if(node.children) node.children.forEach(c=>collect(c)); } data.forEach(root=>collect(root));
  nodes.forEach(n=>{ if(n.children) n.children.forEach(c=>group.appendChild(drawConnector(n._x,n._y,c._x,c._y))); });
  nodes.forEach(n=>{
    const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('class','node'); g.setAttribute('transform',`translate(${n._x},${n._y})`);
    const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x',-BOX_W/2); rect.setAttribute('y',-BOX_H/2);
    rect.setAttribute('width',BOX_W); rect.setAttribute('height',BOX_H);
    rect.setAttribute('rx',8); rect.setAttribute('ry',8);
    // Color based on type
    if(n.type==="group") rect.setAttribute('fill','#ffffff');
    else if(n.type==="living") rect.setAttribute('fill','rgba(0,128,0,0.1)');
    else rect.setAttribute('fill','var(--box)');
    rect.setAttribute('stroke','var(--accent)');
    const text=document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('text-anchor','middle'); text.setAttribute('dy','6'); text.textContent=n.name;
    g.appendChild(rect); g.appendChild(text);
    // Node click disabled (no popups)
    g.addEventListener('click', e=>{ e.stopPropagation(); });
    group.appendChild(g);
  });
  const xs=nodes.map(n=>n._x); const minX=Math.min(...xs); const maxX=Math.max(...xs); const treeWidth=maxX-minX+BOX_W; const svgW=window.innerWidth;
  panX=(svgW-treeWidth)/2 - minX + BOX_W/2; panY=20; scale=1; applyTransform();
}

// ---------------- Load JSON ----------------
async function loadAndRender(){ 
  try{ 
    const resp=await fetch('./languages.json'); 
    if(!resp.ok) throw new Error('HTTP '+resp.status); 
    const data=await resp.json(); 
    buildTree(data); 
    // Intro popup only
    showPopup('Welcome to the Tree of Languages','This site shows a diagram of languages and their genetics. You can also see what languages derived from the same ancestor. White represents a linguistic group and green represents a living language.                           Created by Sebastian G. F. Archibald');
  }catch(err){ 
    console.error('Failed to load languages.json',err); 
    showPopup('Error','Could not load languages.json — make sure the file exists next to index.html and the repo is public.'); 
  } 
}
loadAndRender();
window.addEventListener('resize', ()=>{ loadAndRender(); });
window.addEventListener('keydown', e=>{ if(e.key==='Escape') hidePopup(); });

// ---------------- Search autocomplete ----------------
searchBox.addEventListener('input', ()=>{
  const query = searchBox.value.toLowerCase();
  searchDropdown.innerHTML=''; if(!query){ searchDropdown.style.display='none'; return; }
  const matches = allNodes.filter(n=>n.name.toLowerCase().includes(query)).slice(0,8);
  if(matches.length===0){ searchDropdown.style.display='none'; return; }
  matches.forEach(n=>{
    const div = document.createElement('div'); div.textContent=n.name;
    div.style.padding='4px 6px'; div.style.cursor='pointer';
    div.addEventListener('mouseenter',()=>{ div.style.background='#f0f0f0'; });
    div.addEventListener('mouseleave',()=>{ div.style.background='#fff'; });
    div.addEventListener('click', ()=>{
      const svgRect = svg.getBoundingClientRect();
      const centerX = svgRect.width / 2;
      const centerY = svgRect.height / 2;
      panX = centerX - n._x*scale;
      panY = centerY - n._y*scale;
      scale = Math.min(2, Math.max(0.8, scale));
      applyTransform();
      searchDropdown.style.display='none'; searchBox.value='';
    });
    searchDropdown.appendChild(div);
  });
  searchDropdown.style.display='block';
});
document.addEventListener('click', (e)=>{
  if(!searchBox.contains(e.target) && !searchDropdown.contains(e.target)){ searchDropdown.style.display='none'; }
});
</script>
</body>
</html>
