<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Language Tree</title>
<style>
body { font-family: Arial; background: #f4f4f4; margin:0; padding:20px; overflow:hidden; }
h1 { text-align: center; margin-bottom: 30px; }

#tree-container {
  width: 100%;
  height: 90vh;
  border:1px solid #ccc;
  background:#fff;
  position: relative;
  cursor: grab;
}

svg { width: 100%; height: 100%; }

.node rect { fill:#fff; stroke:#ccc; stroke-width:2; rx:5; ry:5; }
.node text { font-size:14px; pointer-events:none; }
.node:hover rect { fill:#e6f7ff; stroke:#1e90ff; cursor:pointer; }

.popup {
  position: fixed; top:50%; left:50%;
  transform: translate(-50%, -50%);
  background:#fff; border:2px solid #1e90ff;
  border-radius:10px; padding:20px;
  display:none; z-index:1000; max-width:80%;
  box-shadow:0 5px 15px rgba(0,0,0,0.3);
}
.popup h2 { margin-top:0; }
.popup .close { cursor:pointer; float:right; font-weight:bold; font-size:20px; color:#1e90ff; }
.overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.3); display:none; z-index:900; }
</style>
</head>
<body>
<h1>Interactive Language Tree</h1>
<div id="tree-container">
  <svg id="tree-svg">
    <g id="tree-group"></g>
  </svg>
</div>

<div class="overlay"></div>
<div class="popup" id="popup">
  <span class="close" id="closePopup">&times;</span>
  <h2 id="popupTitle"></h2>
  <p id="popupInfo"></p>
</div>

<script>
// ------------------ DATA ------------------
const treeData = [
  {
    name: "Indo-European",
    info: "Root family with many languages in Europe and Asia.",
    children: [
      {
        name: "Germanic",
        info: "English, German, Dutch, Scandinavian.",
        children: [
          {name:"English", info:"~380 million speakers."},
          {name:"German", info:"Spoken in Germany, Austria, Switzerland."}
        ]
      },
      {
        name: "Romance",
        info: "Derived from Latin.",
        children: [
          {name:"Spanish", info:"~460 million speakers."},
          {name:"French", info:"Spoken in France, Canada, Africa."}
        ]
      }
    ]
  },
  {
    name: "Uralic",
    info: "Includes Finnish, Hungarian, Estonian.",
    children: [
      {name:"Finnish", info:"Spoken in Finland."},
      {name:"Hungarian", info:"Spoken in Hungary."},
      {name:"Estonian", info:"Spoken in Estonia."}
    ]
  }
];

// ------------------ TREE LAYOUT ------------------
const svg = document.getElementById('tree-svg');
const treeGroup = document.getElementById('tree-group');
const width = svg.clientWidth;
const height = svg.clientHeight;

let panX = 0, panY = 0, scale = 1;
let isDragging = false, startX, startY;

// Recursive layout
function layoutTree(data, startX, startY, dx=200, dy=100){
  let nodes = [];
  let links = [];

  function traverse(node, x, y){
    node.x = x;
    node.y = y;
    nodes.push(node);
    if(node.children){
      const n = node.children.length;
      const startChildX = x - dx*(n-1)/2;
      node.children.forEach((child,i)=>{
        const cx = startChildX + i*dx;
        const cy = y + dy;
        // loose step line
        links.push({x1:x, y1:y+15, x2:cx, y2:cy-15});
        traverse(child, cx, cy);
      });
    }
  }

  data.forEach((root,i)=>{
    traverse(root, width/2 + (i-0.5)*400, 50);
  });

  return {nodes, links};
}

// Draw tree
function drawTree(){
  treeGroup.innerHTML = '';
  const {nodes, links} = layoutTree(treeData, width/2, 50);

  // Draw lines
  links.forEach(l=>{
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    const midY = (l.y1 + l.y2)/2;
    const d = `M ${l.x1} ${l.y1} L ${l.x1} ${midY} L ${l.x2} ${midY} L ${l.x2} ${l.y2}`;
    path.setAttribute('d', d);
    path.setAttribute('stroke','#999');
    path.setAttribute('stroke-width','2');
    path.setAttribute('fill','none');
    treeGroup.appendChild(path);
  });

  // Draw nodes
  nodes.forEach(n=>{
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute('class','node');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.dataset.name = n.name;
    g.dataset.info = n.info;

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute('x',-50);
    rect.setAttribute('y',-15);
    rect.setAttribute('width',100);
    rect.setAttribute('height',30);

    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute('text-anchor','middle');
    text.setAttribute('dy','5');
    text.textContent = n.name;

    g.appendChild(rect);
    g.appendChild(text);
    treeGroup.appendChild(g);
  });
}

drawTree();

// ------------------ POPUPS ------------------
svg.addEventListener('click', e=>{
  if(e.target.parentNode.classList.contains('node')){
    const g = e.target.parentNode;
    document.getElementById('popupTitle').textContent = g.dataset.name;
    document.getElementById('popupInfo').textContent = g.dataset.info;
    document.getElementById('popup').style.display='block';
    document.querySelector('.overlay').style.display='block';
  }
});

document.getElementById('closePopup').addEventListener('click', ()=>{
  document.getElementById('popup').style.display='none';
  document.querySelector('.overlay').style.display='none';
});
document.querySelector('.overlay').addEventListener('click', ()=>{
  document.getElementById('popup').style.display='none';
  document.querySelector('.overlay').style.display='none';
});

// ------------------ ZOOM & PAN ------------------
svg.addEventListener('wheel', e=>{
  e.preventDefault();
  const scaleFactor = 1.1;
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;
  const newScale = e.deltaY<0 ? scale*scaleFactor : scale/scaleFactor;

  // Keep scale in bounds
  const clamped = Math.min(Math.max(newScale, 0.2), 3);
  // Adjust pan so zoom centers on cursor
  panX = mouseX - (mouseX - panX) * (clamped/scale);
  panY = mouseY - (mouseY - panY) * (clamped/scale);
  scale = clamped;
  updateTransform();
});

svg.addEventListener('mousedown', e=>{
  isDragging = true;
  startX = e.clientX - panX;
  startY = e.clientY - panY;
  svg.style.cursor='grabbing';
});

window.addEventListener('mousemove', e=>{
  if(!isDragging) return;
  panX = e.clientX - startX;
  panY = e.clientY - startY;
  updateTransform();
});

window.addEventListener('mouseup', e=>{
  isDragging=false;
  svg.style.cursor='grab';
});

function updateTransform(){
  treeGroup.setAttribute('transform', `translate(${panX},${panY}) scale(${scale})`);
}

window.addEventListener('resize', drawTree);
</script>
</body>
</html>
